<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1259"/>

<div>
<span><div><br/></div><div>复习</div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><span style="font-size: 16px;">原型</span></span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><span style="font-size: 16px;">继承 </span></span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><span style="font-size: 16px;">Son.prototype = new Father()</span></span></span></div><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><a name="1099" style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 13.3333px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"></a><div><span style="font-size: 16px;">1、什么是设计模式？</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;">设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。   </span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">2、设计模式之单例模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;">单例：对象只能实例化一次就叫单例</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">单例模式：字面量的对象声明，其实在设计模式中可以看作是一种单例模式，所谓单例模式，就是永远保持对象的一个实例。</span></div><div><span style="font-size: 16px;">var  obj= new Object();</span></div><div><span style="font-size: 16px;">var obj = {};</span></div><div><span style="font-size: 16px;">obj = {}    一次只能创建一个对象  -    单例模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">     //实现单利模式</span></div><div><span style="font-size: 16px;">     //  实现思路：  将第一次new出来的对象 this  保存到一个变量中 ，返回这个变量</span></div><div><span style="font-size: 16px;">     //再次创建对象时，判断  这个变量中是否含有值，如果有值，就直接将这个变量返回</span></div><div><span style="font-size: 16px;">   </span></div><div><span style="font-size: 16px;">     <br/></span></div><div><span style="font-size: 16px;">     function MyPlane(){</span></div><div><span style="font-size: 16px;">          if( MyPlane.instance ){  //在构造函数内部    可以为构造函数指定任意一个属性 用来接收值</span></div><div><span style="font-size: 16px;">               return MyPlane.instance;<br/></span></div><div><span style="font-size: 16px;">          }<br/></span></div><div><span style="font-size: 16px;">          MyPlane.instance = this;</span></div><div><span style="font-size: 16px;">          return MyPlane.instance;<br/></span></div><div><span style="font-size: 16px;">     }    </span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">      </span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">3、设计模式之代理模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;">代理模式: 为其他对象提供一种代理，并以控制对这个对象的访问。</span></div><div><span style="font-size: 16px;">function Mx(){</span></div><div><span style="font-size: 16px;">     this.perfomer = function(){</span></div><div><span style="font-size: 16px;">          console.log( &quot;拍电影&quot; );<br/></span></div><div><span style="font-size: 16px;">     }</span></div><div><span style="font-size: 16px;">     this.music= function(){</span></div><div><span style="font-size: 16px;">          console.log( &quot;演唱会&quot; );<br/></span></div><div><span style="font-size: 16px;">     }<br/></span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">function Jjr(){</span></div><div><span style="font-size: 16px;">     //代理模式</span></div><div><span style="font-size: 16px;">     this.leader = new Mx();</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">     this.music = function(money){</span></div><div><span style="font-size: 16px;">          if( money &gt; 500000 ){ //满足这个条件  就通知主人 可以开演唱会</span></div><div><span style="font-size: 16px;">               this.leader.music();<br/></span></div><div><span style="font-size: 16px;">          }<br/></span></div><div><span style="font-size: 16px;">     }</span></div><div><span style="font-size: 16px;">     this.performer = function(money){</span></div><div><span style="font-size: 16px;">          if( money &gt; 10000000 ){</span></div><div><span style="font-size: 16px;">               this.leader.performer();<br/></span></div><div><span style="font-size: 16px;">          }<br/></span></div><div><span style="font-size: 16px;">     }<br/></span></div><div><span style="font-size: 16px;">}</span></div><div><font size="4">var j = new Jjr();</font></div><div><font size="4">j.music(600000); </font></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">4、设计模式之适配器模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;">适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">//手机 ：打电话　　播放音乐</span></div><div><span style="font-size: 16px;">//pad :只能播放音乐     </span></div><div><span style="font-size: 16px;">//模拟适配器   ：  既可以操作手机  又可以操作  pad ，判断这些产品有哪些功能</span></div><div><span style="font-size: 16px;"><br/></span></div><div><font size="4"> </font></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><br/></span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">5、设计模式之工厂模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div><span style="font-size: 16px;">让对象的调用者和对象创建过程分离，当对象调用者需要对象时，直接向工厂请求即可。从而避免了对象的调用者与对象的实现类似编码方式<span style="color: rgb(255, 0, 0);">耦合</span>，以提高系统的可维护性、可扩展性。</span></div><div><br/></div></div><div><span style="font-size: 16px;"><br/></span></div></div><div><span style="font-size: 16px;">6、设计模式之观察者模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><font size="4"><span>水烧开了----》  沏茶</span></font></div><div><span style="font-size: 16px;">孩子哭了 -- 》  喂奶</span></div><div><span style="font-size: 16px;">12点整  --》  开始宵夜</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">function Child(dad,mum){</span></div><div><span style="font-size: 16px;">     this.dad = dad;</span></div><div><span style="font-size: 16px;">     this.mum = mum;<br/></span></div><div><span style="font-size: 16px;">     this.cry = function(){</span></div><div><span style="font-size: 16px;">          //孩子哭了 通知父亲开始喂奶了</span></div><div><span style="font-size: 16px;">         this.dad.notify();<br/></span></div><div><span style="font-size: 16px;">     }</span></div><div><span style="font-size: 16px;">     setTimeout(function(){</span></div><div><span style="font-size: 16px;">          this.cry();<br/></span></div><div><span style="font-size: 16px;">     },Math.random()*5000)<br/></span></div><div><span style="font-size: 16px;">}</span></div><div><br/></div><div><span style="font-size: 16px;">function Father(){</span></div><div><span style="font-size: 16px;">     this.notify = function(){</span></div><div><span style="font-size: 16px;">          this.喂奶();<br/></span></div><div><span style="font-size: 16px;">     }<br/></span></div><div><span style="font-size: 16px;">     this.喂奶 = function(){</span></div><div><span style="font-size: 16px;">          alert( &quot;孩子哭了，去喂奶吧&quot; );<br/></span></div><div><span style="font-size: 16px;">     }<br/></span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">var f = new Father();</span></div><div><span style="font-size: 16px;">var c = new Child(&quot;dad&quot;,null);</span></div></div><div><br/></div><div><span style="font-size: 16px;">7、策略模式</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><span style="font-size: 16px;">定义一系列算法，把他们一个一个封装起来，并且使他们可以相互替换(具有相同的目标和意图)</span></div><div><span style="font-size: 16px;"><br/></span></div></div><div><br/></div><div><span style="font-size: 16px;">8、闭包</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">一个函数中返回一个匿名函数，这个函数就成为闭包</span></div><div><span style="font-size: 16px;">闭包就是能够读取其它函数内部变量的函数。闭包的存在延长了局部变量的生命周期。闭包的形式多变，但本质都是一样的，即局部函数全局执行。</span></div><div><span style="font-size: 16px;">闭包可以将一个局部变量长期驻留在内存中。</span></div><div><span style="font-size: 16px;">闭包中的this指向的是window对象</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 