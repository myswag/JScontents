<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1253"/>

<div>
<span><div>复习</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">什么是对象</span></div><div><span style="font-size: 16px;">什么是类</span></div><div><span style="font-size: 16px;">什么是面向对象</span></div><div><span style="font-size: 16px;">对象的定义：new Object()     { }</span></div><div><span style="font-size: 16px;">工厂模式 ： 批量创建多个同类对象</span></div><div><span style="font-size: 16px;">function Factory(){</span></div><div><span style="font-size: 16px;">     return obj;<br/></span></div><div><span style="font-size: 16px;">}</span></div><div><font size="4"><span>构造函数 ： </span></font></div><div><span style="font-size: 16px;">function Animal(name){</span></div><div><span style="font-size: 16px;">     this.name = name;</span></div><div><span style="font-size: 16px;">     this.running = function(){</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">     }<br/></span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">a = new Animal()</span></div><div><span style="font-size: 16px;">原型构造函数</span></div><div><span style="font-size: 16px;">混合 ： 实例属性   原型方法</span></div><div><span style="font-size: 16px;"><br/></span></div></div><div><br/></div><div><br/></div><div>1、原型 prototype </div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="font-size: 16px;">所有的构造函数都有一个原型对象  </span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="font-size: 16px;">所有的构造函数new出来的对象也有一个prototype原型对象   实现方式 ： var pro = new Product();   pro.__proto__    等价  Product.prototype</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="font-size: 16px;"><br/></span></span></span></div><div><img src="1705 day24_files/Image.png" type="image/png" style="height:auto;" width="1085"/></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="font-size: 16px;">原型链 ：  通过 .__proto__  获取对象 直到结果为null的这样一个过程 称为一个原型链  </span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">练习 ： </span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">在String的原型上实现   去除字符串两端的空白 方法</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">String.prototype.trim = function(){</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">   return  this.replace( /(^\s+) | (\s+$)/g , &quot;&quot; );<br/></span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="font-size: 16px;"><br/></span></span></span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">2、原型中的几个关键字（扩展）</span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><span style="font-size: 16px;">测试某个对象是否属于某个类的方法 isPrototypeOf()</span></div><div><span style="font-size: 16px;">语法： 构造函数.prototype.isPrototypeOf(对象):判断一个对象是否指向了该构造函数的原型对象，可以使用isPrototypeOf()方法来测试     结果为boolean类型  同  instanceof </span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">delete ：删除<span style="color: rgb(255, 0, 0);">实例</span>属性</span></div><div><span style="font-size: 16px;">语法 ：  delete  对象.实例属性</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">hasOwnProperty() 是否包含该<span style="color: rgb(255, 0, 0);">实例</span>属性,包含返回true，否则返回false</span></div><div><span style="font-size: 16px;">语法： 实例对象.hasOwnProperty(&quot;实例属性&quot;)</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">in 是否存在该属性（原型或实例中）</span></div><div><span style="font-size: 16px;">语法： &quot;属性&quot; in  对象实例</span></div></div><div><br/></div><div><span style="font-size: 16px;">3、原型模式的执行流程</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">1、首先去实例中查找，如果存在实例属性或实例方法，就返回</span></div><div><span style="font-size: 16px;">2、如果没有实例属性或实例方法，去原型中查找，如果有就返回，没有则返回undefined</span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">4、面向对象三个特性</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">封装 ： 屏蔽内部细节（实现）   </span></div><div><span style="font-size: 16px;">继承 ： 子类拥有父类的所有属性和方法  </span></div><div><span style="font-size: 16px;">多态 </span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">5、继承</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">单继承 ： 一个子类只拥有一个父类</span></div><div><span style="font-size: 16px;">多继承 ： 一个子类可以拥有多个父类</span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">6、继承方式一 ： 通过改变父类的执行环境</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">function Father(){</span></div><div><span style="font-size: 16px;">     this.money = 999999;</span></div><div><span style="font-size: 16px;">     this.eat = function(){</span></div><div><span style="font-size: 16px;">          console.log(&quot;吃肉&quot;);<br/></span></div><div><span style="font-size: 16px;">     }</span></div><div><span style="font-size: 16px;">     this.music = function(){</span></div><div><span style="font-size: 16px;">          console.log( &quot;唱歌&quot; );<br/></span></div><div><span style="font-size: 16px;">     }<br/></span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">//alert( Father );</span></div><div><span style="font-size: 16px;">function Son(){</span></div><div><span style="font-size: 16px;">     this.parent = Father;</span></div><div><span style="font-size: 16px;">     this.parent();</span></div><div><span style="font-size: 16px;">     delete this.parent;<br/></span></div><div><span style="font-size: 16px;">}</span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">7、通过call方法改变 父类的this指向</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">function Father(firstName){</span></div><div><span style="font-size: 16px;">     this.firstName = firstName;</span></div><div><span style="font-size: 16px;">     this.money = 9999999;</span></div><div><span style="font-size: 16px;">     this.dance = function(){</span></div><div><span style="font-size: 16px;">          console.log(“跳舞”);</span></div><div><span style="font-size: 16px;">     }<br/></span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">function Son(firstName){</span></div><div><span style="font-size: 16px;">     Father.call( this, firstName);<br/></span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">call方法  会自动继承父类的所有属性和方法   参数：  this   ，   要继承的父类的属性</span></div><div><span style="font-size: 16px;">call : 第一个参数  子类</span></div><div><span style="font-size: 16px;">       第二个参数  要继承的父类的所有属性 （个数不固定）</span></div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">8、通过apply方法改变父类的this指向</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">apply方法：  两个参数</span></div><div><span style="font-size: 16px;">第一个参数： 子类</span></div><div><span style="font-size: 16px;">第二个参数： 数组 （数组中就是要继承的父类的所有属性）</span></div></div><div><br/></div><div><span style="font-size: 16px;">9、原型继承</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">function Father(){</span></div><div><span style="font-size: 16px;">     </span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;">Father.prototype.running = function(){</span></div><div><span style="font-size: 16px;">     console.log(&quot;跑步&quot;);</span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">function Son(){</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">}</span></div><div><span style="font-size: 16px;"><span style="color: rgb(255, 0, 0);">Son.prototype = new Father();</span>  一般用原型继承继承方法   </span></div></div><div><br/></div><div><span style="font-size: 16px;">10、混合继承</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 16px;">通过call或apply的方式 继承 实例属性</span></div><div><span style="font-size: 16px;">通过原型继承的方式继承原型方法</span></div></div><div><br/></div><div>11 、ES6继承</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Father{</div><div>          constructor(firstName,money){</div><div>              this.firstName = firstName;</div><div>              this.money = money;</div><div>          }</div><div>          running(){</div><div>              console.log(&quot;跑步&quot;);</div><div>          }</div><div>          eatting(){</div><div>              console.log(&quot;吃肉&quot;);</div><div>          }</div><div>     }</div><div>     class Son extends Father{</div><div>          constructor(firstName,money,score){</div><div>              super(firstName,money);//继承父类的属性   方法也自动继承</div><div>              this.score = score;//子类特有的属性实现</div><div>          }</div><div>     }</div><div>     var son = new Son(&quot;王&quot;,&quot;221111&quot;,90);</div><div>     console.log( son );</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 